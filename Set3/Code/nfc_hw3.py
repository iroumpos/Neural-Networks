# -*- coding: utf-8 -*-
"""nfc_hw3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1h1FJeWmcPTI0-AxurCF4JSnQdv_DNh7E

# ASKISI 3
"""

import numpy as np

# Define the learning rate
alpha = 0.5


p1 = np.array([1, 1])
p2 = np.array([-1, 2])
p3 = np.array([-2, -2])


w1 = np.array([0.0, 1.0])
w2 = np.array([1.0, 0.0])

# Define the presentation order
presentation_order = [p1, p2, p3, p2, p3, p1]


w1_updates = []
w2_updates = []


for p in presentation_order:

    n1 = -np.linalg.norm(p - w1)
    n2 = -np.linalg.norm(p - w2)

    # Find the winning neuron
    if n1 > n2:
        winner = 1
    else:
        winner = 2


    if winner == 1:
        w1_updates.append(w1.copy())
        w1 += alpha * (p - w1)
    else:
        w2_updates.append(w2.copy())
        w2 += alpha * (p - w2)

# Print the final weights
print("Final weights:")
print("w1:", w1)
print("w2:", w2)

# Print the weight updates
print("\nWeight updates:")
print("w1 updates:", w1_updates)
print("w2 updates:", w2_updates)

"""# ASKISI 4"""

import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

# Define the learning rate
alpha = 0.5

# Define the input vectors
p1 = np.array([2, 0])
p2 = np.array([0, 1])
p3 = np.array([2, 2])


w1_initial = np.array([1.0, 0.0])
w2_initial = np.array([-1.0, 0.0])
w1 = w1_initial.copy()
w2 = w2_initial.copy()

# Define the presentation order
presentation_order = [p1, p2, p3, p2, p3, p1]


w1_updates = [w1_initial]
w2_updates = [w2_initial]


for p in presentation_order:

    n1 = -np.linalg.norm(p - w1)
    n2 = -np.linalg.norm(p - w2)


    if n1 > n2:
        winner = 1
    else:
        winner = 2

    # Update the weights of the winning neuron
    if winner == 1:
        w1 += alpha * (p - w1)
        w1_updates.append(w1.copy())
    else:
        w2 += alpha * (p - w2)
        w2_updates.append(w2.copy())


w1_updates = np.array(w1_updates)
w2_updates = np.array(w2_updates)

# values of the weight updates
plt.figure(figsize=(8, 6))
sns.lineplot(x=w1_updates[:, 0], y=w1_updates[:, 1], label='w1_updates', marker='o')
sns.lineplot(x=w2_updates[:, 0], y=w2_updates[:, 1], label='w2_updates', marker='o')

# initial positions of w1 and w2
plt.plot(w1_initial[0], w1_initial[1], 'b*', markersize=10, label='w1_initial')
plt.plot(w2_initial[0], w2_initial[1], 'r*', markersize=10, label='w2_initial')

plt.xlabel('X')
plt.ylabel('Y')
plt.title('Weight Updates')
plt.legend()
plt.grid(True)
plt.show()

import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt


alpha = 0.5


p1 = np.array([2, 0])
p2 = np.array([0, 1])
p3 = np.array([2, 2])


w1_initial = np.array([1.0, 0.0])
w2_initial = np.array([-1.0, 0.0])
w1 = w1_initial.copy()
w2 = w2_initial.copy()

# to
presentation_order = [p1, p2, p3, p2, p3, p1,p1, p2, p3, p2, p3, p1,p1, p2, p3, p2, p3, p1]

# Initialize lists to store weight updates
w1_updates = [w1_initial]
w2_updates = [w2_initial]


for p in presentation_order:

    n1 = -np.linalg.norm(p - w1)
    n2 = -np.linalg.norm(p - w2)

    # winning neuron
    if n1 > n2:
        winner = 1
    else:
        winner = 2

    # Update the weights of the winning neuron
    if winner == 1:
        w1 += alpha * (p - w1)
        w1_updates.append(w1.copy())
    else:
        w2 += alpha * (p - w2)
        w2_updates.append(w2.copy())


w1_updates = np.array(w1_updates)
w2_updates = np.array(w2_updates)

# Plot the values of the weight updates
plt.figure(figsize=(8, 6))
sns.lineplot(x=w1_updates[:, 0], y=w1_updates[:, 1], label='w1_updates', marker='o')
sns.lineplot(x=w2_updates[:, 0], y=w2_updates[:, 1], label='w2_updates', marker='o')

# initial positions of w1 and w2
plt.plot(w1_initial[0], w1_initial[1], 'b*', markersize=10, label='w1_initial')
plt.plot(w2_initial[0], w2_initial[1], 'r*', markersize=10, label='w2_initial')

# final positions of w1 and w2
plt.plot(w1[0], w1[1], 'bs', markersize=12, label='w1_final')  # Blue square marker for w1 final
plt.plot(w2[0], w2[1], 'rs', markersize=12, label='w2_final')  # Red square marker for w2 final

# Annotate points p1, p2, and p3 and indicate if they are closer to w1 or w2
for point, label in zip([p1, p2, p3], ['p1', 'p2', 'p3']):
    dist_w1 = np.linalg.norm(w1 - point)
    dist_w2 = np.linalg.norm(w2 - point)
    if dist_w1 < dist_w2:
        plt.annotate(f'{label} (closer to w1 final)', (point[0], point[1]), textcoords="offset points", xytext=(-10,10), ha='center')
    else:
        plt.annotate(f'{label} (closer to w2 final)', (point[0], point[1]), textcoords="offset points", xytext=(-10,10), ha='center')

# Plot p1, p2, and p3
plt.scatter([p1[0], p2[0], p3[0]], [p1[1], p2[1], p3[1]], color='black', marker='o', label='p1, p2, p3')

plt.xlabel('X')
plt.ylabel('Y')
plt.title('Weight Updates')
plt.legend()
plt.grid(True)
plt.ylim(-1, 3)
plt.show()